{"ast":null,"code":"var _jsxFileName = \"/home/keviin/ramp-fe-challenge/ramp-fe-challenge/src/App.tsx\",\n    _s = $RefreshSig$();\n\n/* \n    Bug 3 fix\n      - call loadAllTransactions() if newValue's (if it exists) id, when the onChange callback is called, is empty\n    Bug 5 fix\n      - moved setIsLoading(false) after employees callback and before paginatedTransactions callback (fixes Part 1 and 2)\n      Part 1: once the employees promise is resolved, the loading is finished rather than when both paginatedTransactions' promise and \n      employees' promise are resolved\n      Part 2: moving the setIsLoading(false) before paginatedTransactions fixes part 2 because we no longer need to wait for the next page of paginated data\n        to be fetched for the employees to show up\n    Bug 6 fixes\n      - added boolean conditional before rendering View More button to check whether \n        the transaction is by an employee (in which case it isn't paginated per the README and therefore no need to render View More button)\n      - added boolean conditional before rendering View More button to check whether \n        the transaction (if paginated) has a next page. if it doesn't no need to render.\n    \n    Bug 7 fix\n      - moved invalidate data after the fetch since nulling the state variable fetching causes any approval changes to be lost\n*/\nimport { Fragment, useCallback, useEffect, useMemo, useState } from \"react\";\nimport { InputSelect } from \"./components/InputSelect\";\nimport { Instructions } from \"./components/Instructions\";\nimport { Transactions } from \"./components/Transactions\";\nimport { useEmployees } from \"./hooks/useEmployees\";\nimport { usePaginatedTransactions } from \"./hooks/usePaginatedTransactions\";\nimport { useTransactionsByEmployee } from \"./hooks/useTransactionsByEmployee\";\nimport { EMPTY_EMPLOYEE } from \"./utils/constants\";\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nexport function App() {\n  _s();\n\n  const {\n    data: employees,\n    ...employeeUtils\n  } = useEmployees();\n  const {\n    data: paginatedTransactions,\n    ...paginatedTransactionsUtils\n  } = usePaginatedTransactions();\n  const {\n    data: transactionsByEmployee,\n    ...transactionsByEmployeeUtils\n  } = useTransactionsByEmployee();\n  const [isLoading, setIsLoading] = useState(false);\n  const transactions = useMemo(() => {\n    var _ref, _paginatedTransaction;\n\n    return (_ref = (_paginatedTransaction = paginatedTransactions === null || paginatedTransactions === void 0 ? void 0 : paginatedTransactions.data) !== null && _paginatedTransaction !== void 0 ? _paginatedTransaction : transactionsByEmployee) !== null && _ref !== void 0 ? _ref : null;\n  }, [paginatedTransactions, transactionsByEmployee]);\n  const loadAllTransactions = useCallback(async () => {\n    // called when All Employee transactions need to be fetched\n    setIsLoading(true);\n    await employeeUtils.fetchAll();\n    /* \n      Bug 5 fix\n      Part 1: once the employees promise is resolved, the loading is finished rather than when both paginatedTransactions' promise and \n      employees' promise are resolved\n      Part 2: moving the setIsLoading(false) before paginatedTransactions fixes part 2 because we no longer need to wait for the next page of paginated data\n        to be fetched for the employees to show up\n    */\n\n    setIsLoading(false); // moved setIsLoading(false) after employees callback and before paginatedTransactions callback (fixes Part 1 and 2)\n\n    await paginatedTransactionsUtils.fetchAll();\n    /*\n      Bug 7 fix\n      moved transactionsByEmployeeUtils.invalidateData() the fetch since nulling the state variable fetching causes any approval changes to be lost\n    */\n\n    transactionsByEmployeeUtils.invalidateData();\n  }, [employeeUtils, paginatedTransactionsUtils, transactionsByEmployeeUtils]);\n  const loadTransactionsByEmployee = useCallback( // called when a specific employee's transactions need to be fetched\n  async employeeId => {\n    await transactionsByEmployeeUtils.fetchById(employeeId);\n    /*\n      Bug 7 fix\n      moved paginatedTransactionsUtils.invalidateData() after the fetch since nulling the state variable fetching causes any approval changes to be lost\n    */\n\n    paginatedTransactionsUtils.invalidateData();\n  }, [paginatedTransactionsUtils, transactionsByEmployeeUtils]);\n  useEffect(() => {\n    if (employees === null && !employeeUtils.loading) {\n      loadAllTransactions();\n    }\n  }, [employeeUtils.loading, employees, loadAllTransactions]);\n  return /*#__PURE__*/_jsxDEV(Fragment, {\n    children: /*#__PURE__*/_jsxDEV(\"main\", {\n      className: \"MainContainer\",\n      children: [/*#__PURE__*/_jsxDEV(Instructions, {}, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 82,\n        columnNumber: 9\n      }, this), /*#__PURE__*/_jsxDEV(\"hr\", {\n        className: \"RampBreak--l\"\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 84,\n        columnNumber: 9\n      }, this), /*#__PURE__*/_jsxDEV(InputSelect, {\n        isLoading: isLoading,\n        defaultValue: EMPTY_EMPLOYEE,\n        items: employees === null ? [] : [EMPTY_EMPLOYEE, ...employees],\n        label: \"Filter by employee\",\n        loadingLabel: \"Loading employees\",\n        parseItem: item => ({\n          value: item.id,\n          label: `${item.firstName} ${item.lastName}`\n        }),\n        onChange: async newValue => {\n          /*\n            Bug 3 fix\n              - call loadAllTransactions() if newValue's (if it exists) id, when the onChange callback is called, is empty\n          */\n          // We want to check if newValue id is null since the All Employee object does exist so the initial newValue === null would never validate even if there's no id.\n          if (!(newValue !== null && newValue !== void 0 && newValue.id)) {\n            // Bug 3 fix\n            await loadAllTransactions();\n            return;\n          }\n\n          await loadTransactionsByEmployee(newValue.id);\n        }\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 86,\n        columnNumber: 9\n      }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n        className: \"RampBreak--l\"\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 112,\n        columnNumber: 9\n      }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n        className: \"RampGrid\",\n        children: [/*#__PURE__*/_jsxDEV(Transactions, {\n          transactions: transactions\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 115,\n          columnNumber: 11\n        }, this),\n        /* Bug 6 fixes\n          - added boolean conditional before rendering View More button to check whether \n            the transaction is by an employee (in which case it isn't paginated per the README and therefore no need to render View More button)\n          - added boolean conditional before rendering View More button to check whether \n            the transaction (if paginated) has a next page. if it doesn't no need to render.\n        */\n        paginatedTransactions && (paginatedTransactions === null || paginatedTransactions === void 0 ? void 0 : paginatedTransactions.nextPage) !== null && transactions !== null && /*#__PURE__*/_jsxDEV(\"button\", {\n          className: \"RampButton\",\n          disabled: paginatedTransactionsUtils.loading,\n          onClick: async () => {\n            await loadAllTransactions();\n          },\n          children: \"View More\"\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 127,\n          columnNumber: 13\n        }, this)]\n      }, void 0, true, {\n        fileName: _jsxFileName,\n        lineNumber: 114,\n        columnNumber: 9\n      }, this)]\n    }, void 0, true, {\n      fileName: _jsxFileName,\n      lineNumber: 81,\n      columnNumber: 7\n    }, this)\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 80,\n    columnNumber: 5\n  }, this);\n}\n\n_s(App, \"yXHk/2qvl++XLkP2SZkJsf+Vph0=\", false, function () {\n  return [useEmployees, usePaginatedTransactions, useTransactionsByEmployee];\n});\n\n_c = App;\n\nvar _c;\n\n$RefreshReg$(_c, \"App\");","map":{"version":3,"names":["Fragment","useCallback","useEffect","useMemo","useState","InputSelect","Instructions","Transactions","useEmployees","usePaginatedTransactions","useTransactionsByEmployee","EMPTY_EMPLOYEE","App","data","employees","employeeUtils","paginatedTransactions","paginatedTransactionsUtils","transactionsByEmployee","transactionsByEmployeeUtils","isLoading","setIsLoading","transactions","loadAllTransactions","fetchAll","invalidateData","loadTransactionsByEmployee","employeeId","fetchById","loading","item","value","id","label","firstName","lastName","newValue","nextPage"],"sources":["/home/keviin/ramp-fe-challenge/ramp-fe-challenge/src/App.tsx"],"sourcesContent":["/* \n    Bug 3 fix\n      - call loadAllTransactions() if newValue's (if it exists) id, when the onChange callback is called, is empty\n    Bug 5 fix\n      - moved setIsLoading(false) after employees callback and before paginatedTransactions callback (fixes Part 1 and 2)\n      Part 1: once the employees promise is resolved, the loading is finished rather than when both paginatedTransactions' promise and \n      employees' promise are resolved\n      Part 2: moving the setIsLoading(false) before paginatedTransactions fixes part 2 because we no longer need to wait for the next page of paginated data\n        to be fetched for the employees to show up\n    Bug 6 fixes\n      - added boolean conditional before rendering View More button to check whether \n        the transaction is by an employee (in which case it isn't paginated per the README and therefore no need to render View More button)\n      - added boolean conditional before rendering View More button to check whether \n        the transaction (if paginated) has a next page. if it doesn't no need to render.\n    \n    Bug 7 fix\n      - moved invalidate data after the fetch since nulling the state variable fetching causes any approval changes to be lost\n*/\nimport { Fragment, useCallback, useEffect, useMemo, useState } from \"react\"\nimport { InputSelect } from \"./components/InputSelect\"\nimport { Instructions } from \"./components/Instructions\"\nimport { Transactions } from \"./components/Transactions\"\nimport { useEmployees } from \"./hooks/useEmployees\"\nimport { usePaginatedTransactions } from \"./hooks/usePaginatedTransactions\"\nimport { useTransactionsByEmployee } from \"./hooks/useTransactionsByEmployee\"\nimport { EMPTY_EMPLOYEE } from \"./utils/constants\"\nimport { Employee } from \"./utils/types\"\n\nexport function App() {\n  const { data: employees, ...employeeUtils } = useEmployees()\n  const { data: paginatedTransactions, ...paginatedTransactionsUtils } = usePaginatedTransactions()\n  const { data: transactionsByEmployee, ...transactionsByEmployeeUtils } = useTransactionsByEmployee()\n  const [isLoading, setIsLoading] = useState(false)\n\n  const transactions = useMemo(\n    () => paginatedTransactions?.data ?? transactionsByEmployee ?? null,\n    [paginatedTransactions, transactionsByEmployee]\n  )\n\n  const loadAllTransactions = useCallback(async () => { // called when All Employee transactions need to be fetched\n    setIsLoading(true)\n    await employeeUtils.fetchAll()\n    /* \n      Bug 5 fix\n      Part 1: once the employees promise is resolved, the loading is finished rather than when both paginatedTransactions' promise and \n      employees' promise are resolved\n      Part 2: moving the setIsLoading(false) before paginatedTransactions fixes part 2 because we no longer need to wait for the next page of paginated data\n        to be fetched for the employees to show up\n    */\n    setIsLoading(false) // moved setIsLoading(false) after employees callback and before paginatedTransactions callback (fixes Part 1 and 2)\n    await paginatedTransactionsUtils.fetchAll()\n    \n    /*\n      Bug 7 fix\n      moved transactionsByEmployeeUtils.invalidateData() the fetch since nulling the state variable fetching causes any approval changes to be lost\n    */\n    transactionsByEmployeeUtils.invalidateData()\n\n  }, [employeeUtils, paginatedTransactionsUtils, transactionsByEmployeeUtils])\n\n  const loadTransactionsByEmployee = useCallback( // called when a specific employee's transactions need to be fetched\n    async (employeeId: string) => {\n      await transactionsByEmployeeUtils.fetchById(employeeId)\n      /*\n        Bug 7 fix\n        moved paginatedTransactionsUtils.invalidateData() after the fetch since nulling the state variable fetching causes any approval changes to be lost\n      */\n      paginatedTransactionsUtils.invalidateData()\n    },\n    [paginatedTransactionsUtils, transactionsByEmployeeUtils]\n  )\n\n  useEffect(() => {\n    if (employees === null && !employeeUtils.loading) {\n      loadAllTransactions()\n    }\n  }, [employeeUtils.loading, employees, loadAllTransactions])\n\n  return (\n    <Fragment>\n      <main className=\"MainContainer\">\n        <Instructions />\n\n        <hr className=\"RampBreak--l\" />\n\n        <InputSelect<Employee>\n          isLoading={isLoading}\n          defaultValue={EMPTY_EMPLOYEE}\n          items={employees === null ? [] : [EMPTY_EMPLOYEE, ...employees]}\n          label=\"Filter by employee\"\n          loadingLabel=\"Loading employees\"\n          parseItem={(item) => ({\n            value: item.id,\n            label: `${item.firstName} ${item.lastName}`,\n          })}\n          onChange={async (newValue) => {\n            /*\n              Bug 3 fix\n                - call loadAllTransactions() if newValue's (if it exists) id, when the onChange callback is called, is empty\n            */\n            // We want to check if newValue id is null since the All Employee object does exist so the initial newValue === null would never validate even if there's no id.\n            if (!newValue?.id) { \n              // Bug 3 fix\n              await loadAllTransactions() \n              return\n            }\n\n            await loadTransactionsByEmployee(newValue.id)\n          }}\n        />\n\n        <div className=\"RampBreak--l\" />\n\n        <div className=\"RampGrid\">\n          <Transactions transactions={transactions} /> \n          {\n            /* Bug 6 fixes\n              - added boolean conditional before rendering View More button to check whether \n                the transaction is by an employee (in which case it isn't paginated per the README and therefore no need to render View More button)\n              - added boolean conditional before rendering View More button to check whether \n                the transaction (if paginated) has a next page. if it doesn't no need to render.\n            */\n            paginatedTransactions &&  \n            paginatedTransactions?.nextPage !== null &&\n            transactions !== null && \n            ( \n            <button\n              className=\"RampButton\"\n              disabled={paginatedTransactionsUtils.loading}\n              onClick={async () => {\n                await loadAllTransactions()\n              }}\n            >\n              View More\n            </button>\n          )}\n        </div>\n      </main>\n    </Fragment>\n  )\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}